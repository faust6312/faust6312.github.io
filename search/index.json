[{"content":"1.账号保活 由于ser00的账号3个月不ssh连接或者不登录网页面板的话账号就会被回收，故需要隔一段时间登录一下避免账号回收。这里使用的是cf wocker实现定时登录并接入telegrame-bot提示登录信息。 worker代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 addEventListener(\u0026#39;fetch\u0026#39;, event =\u0026gt; { event.respondWith(handleRequest(event.request)) }) addEventListener(\u0026#39;scheduled\u0026#39;, event =\u0026gt; { event.waitUntil(handleScheduled(event.scheduledTime)) }) async function handleRequest(request) { return new Response(\u0026#39;Worker is running\u0026#39;) } async function handleScheduled(scheduledTime) { const accounts = JSON.parse(ACCOUNTS_JSON) const results = await loginAccounts(accounts) await sendSummary(results) } async function loginAccounts(accounts) { const results = [] for (const account of accounts) { const result = await loginAccount(account) results.push({ ...account, ...result }) await delay(Math.floor(Math.random() * 8000) + 1000) } return results } function generateRandomUserAgent() { const browsers = [\u0026#39;Chrome\u0026#39;, \u0026#39;Firefox\u0026#39;, \u0026#39;Safari\u0026#39;, \u0026#39;Edge\u0026#39;, \u0026#39;Opera\u0026#39;]; const browser = browsers[Math.floor(Math.random() * browsers.length)]; const version = Math.floor(Math.random() * 100) + 1; const os = [\u0026#39;Windows NT 10.0\u0026#39;, \u0026#39;Macintosh\u0026#39;, \u0026#39;X11\u0026#39;]; const selectedOS = os[Math.floor(Math.random() * os.length)]; const osVersion = selectedOS === \u0026#39;X11\u0026#39; ? \u0026#39;Linux x86_64\u0026#39; : selectedOS === \u0026#39;Macintosh\u0026#39; ? \u0026#39;Intel Mac OS X 10_15_7\u0026#39; : \u0026#39;Win64; x64\u0026#39;; return `Mozilla/5.0 (${selectedOS}; ${osVersion}) AppleWebKit/537.36 (KHTML, like Gecko) ${browser}/${version}.0.0.0 Safari/537.36`; } async function loginAccount(account) { const { username, password, panelnum, type } = account let url = type === \u0026#39;ct8\u0026#39; ? \u0026#39;https://panel.ct8.pl/login/?next=/\u0026#39; : `https://panel${panelnum}.serv00.com/login/?next=/` const userAgent = generateRandomUserAgent(); try { const response = await fetch(url, { method: \u0026#39;GET\u0026#39;, headers: { \u0026#39;User-Agent\u0026#39;: userAgent, }, }) const pageContent = await response.text() const csrfMatch = pageContent.match(/name=\u0026#34;csrfmiddlewaretoken\u0026#34; value=\u0026#34;([^\u0026#34;]*)\u0026#34;/) const csrfToken = csrfMatch ? csrfMatch[1] : null if (!csrfToken) { throw new Error(\u0026#39;CSRF token not found\u0026#39;) } const initialCookies = response.headers.get(\u0026#39;set-cookie\u0026#39;) || \u0026#39;\u0026#39; const formData = new URLSearchParams({ \u0026#39;username\u0026#39;: username, \u0026#39;password\u0026#39;: password, \u0026#39;csrfmiddlewaretoken\u0026#39;: csrfToken, \u0026#39;next\u0026#39;: \u0026#39;/\u0026#39; }) const loginResponse = await fetch(url, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, \u0026#39;Referer\u0026#39;: url, \u0026#39;User-Agent\u0026#39;: userAgent, \u0026#39;Cookie\u0026#39;: initialCookies, }, body: formData.toString(), redirect: \u0026#39;manual\u0026#39; }) console.log(`Login response status: ${loginResponse.status}`) console.log(`Login response headers: ${JSON.stringify(Object.fromEntries(loginResponse.headers))}`) const loginResponseBody = await loginResponse.text() console.log(`Login response body: ${loginResponseBody.substring(0, 200)}...`) if (loginResponse.status === 302 \u0026amp;\u0026amp; loginResponse.headers.get(\u0026#39;location\u0026#39;) === \u0026#39;/\u0026#39;) { const loginCookies = loginResponse.headers.get(\u0026#39;set-cookie\u0026#39;) || \u0026#39;\u0026#39; const allCookies = combineCookies(initialCookies, loginCookies) const dashboardResponse = await fetch(url.replace(\u0026#39;/login/\u0026#39;, \u0026#39;/\u0026#39;), { headers: { \u0026#39;Cookie\u0026#39;: allCookies, \u0026#39;User-Agent\u0026#39;: userAgent, } }) const dashboardContent = await dashboardResponse.text() console.log(`Dashboard content: ${dashboardContent.substring(0, 200)}...`) if (dashboardContent.includes(\u0026#39;href=\u0026#34;/logout/\u0026#34;\u0026#39;) || dashboardContent.includes(\u0026#39;href=\u0026#34;/wyloguj/\u0026#34;\u0026#39;)) { const nowUtc = formatToISO(new Date()) const nowBeijing = formatToISO(new Date(Date.now() + 8 * 60 * 60 * 1000)) const message = `账号 ${username} (${type}) 于北京时间 ${nowBeijing}（UTC时间 ${nowUtc}）登录成功！` console.log(message) await sendTelegramMessage(message) return { success: true, message } } else { const message = `账号 ${username} (${type}) 登录后未找到登出链接，可能登录失败。` console.error(message) await sendTelegramMessage(message) return { success: false, message } } } else if (loginResponseBody.includes(\u0026#39;Nieprawidłowy login lub hasło\u0026#39;)) { const message = `账号 ${username} (${type}) 登录失败：用户名或密码错误。` console.error(message) await sendTelegramMessage(message) return { success: false, message } } else { const message = `账号 ${username} (${type}) 登录失败，未知原因。请检查账号和密码是否正确。` console.error(message) await sendTelegramMessage(message) return { success: false, message } } } catch (error) { const message = `账号 ${username} (${type}) 登录时出现错误: ${error.message}` console.error(message) await sendTelegramMessage(message) return { success: false, message } } } function combineCookies(cookies1, cookies2) { const cookieMap = new Map() const parseCookies = (cookieString) =\u0026gt; { cookieString.split(\u0026#39;,\u0026#39;).forEach(cookie =\u0026gt; { const [fullCookie] = cookie.trim().split(\u0026#39;;\u0026#39;) const [name, value] = fullCookie.split(\u0026#39;=\u0026#39;) if (name \u0026amp;\u0026amp; value) { cookieMap.set(name.trim(), value.trim()) } }) } parseCookies(cookies1) parseCookies(cookies2) return Array.from(cookieMap.entries()).map(([name, value]) =\u0026gt; `${name}=${value}`).join(\u0026#39;; \u0026#39;) } async function sendSummary(results) { const successfulLogins = results.filter(r =\u0026gt; r.success) const failedLogins = results.filter(r =\u0026gt; !r.success) let summaryMessage = \u0026#39;登录结果统计：\\n\u0026#39; summaryMessage += `成功登录的账号：${successfulLogins.length}\\n` summaryMessage += `登录失败的账号：${failedLogins.length}\\n` if (failedLogins.length \u0026gt; 0) { summaryMessage += \u0026#39;\\n登录失败的账号列表：\\n\u0026#39; failedLogins.forEach(({ username, type, message }) =\u0026gt; { summaryMessage += `- ${username} (${type}): ${message}\\n` }) } console.log(summaryMessage) await sendTelegramMessage(summaryMessage) } async function sendTelegramMessage(message) { const telegramConfig = JSON.parse(TELEGRAM_JSON) const { telegramBotToken, telegramBotUserId } = telegramConfig const url = `https://api.telegram.org/bot${telegramBotToken}/sendMessage` try { await fetch(url, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ chat_id: telegramBotUserId, text: message }) }) } catch (error) { console.error(\u0026#39;Error sending Telegram message:\u0026#39;, error) } } function formatToISO(date) { return date.toISOString().replace(\u0026#39;T\u0026#39;, \u0026#39; \u0026#39;).replace(\u0026#39;Z\u0026#39;, \u0026#39;\u0026#39;).replace(/\\.\\d{3}Z/, \u0026#39;\u0026#39;) } function delay(ms) { return new Promise(resolve =\u0026gt; setTimeout(resolve, ms)) } 变量： ACCOUNTS_JSON 1 2 3 4 5 6 7 [ { \u0026#34;username\u0026#34;: \u0026#34;serv00user1\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;serv00password1\u0026#34;, \u0026#34;panelnum\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;serv00\u0026#34; }, { \u0026#34;username\u0026#34;: \u0026#34;serv00user2\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;serv00password2\u0026#34;, \u0026#34;panelnum\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;serv00\u0026#34; }, { \u0026#34;username\u0026#34;: \u0026#34;serv00user3\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;serv00password3\u0026#34;, \u0026#34;panelnum\u0026#34;: \u0026#34;7\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;serv00\u0026#34; }, { \u0026#34;username\u0026#34;: \u0026#34;ct8user1\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;ct8password1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;ct8\u0026#34; }, { \u0026#34;username\u0026#34;: \u0026#34;ct8user2\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;ct8password2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;ct8\u0026#34; } ] TELEGRAM_JSON 1 2 3 4 { \u0026#34;telegramBotToken\u0026#34;: \u0026#34;YOUR_BOT_TOKEN\u0026#34;, \u0026#34;telegramBotUserId\u0026#34;: \u0026#34;YOUR_USER_ID\u0026#34; } cron任务设置 然后就可以触发一下看能不能登录成功 telegrame成功推送信息就ok了 2.进程保活 因为serv00会不定时清空进程和我们设置的cron任务，每次添加cron任务会很麻烦，便通过脚本一键添加cron任务。 wocker: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 addEventListener(\u0026#39;fetch\u0026#39;, event =\u0026gt; { event.respondWith(handleRequest(event.request)) }) addEventListener(\u0026#39;scheduled\u0026#39;, event =\u0026gt; { event.waitUntil(handleScheduled(event.scheduledTime)) }) async function handleRequest(request) { const url = new URL(request.url) if (url.pathname === \u0026#39;/login\u0026#39; \u0026amp;\u0026amp; request.method === \u0026#39;POST\u0026#39;) { const formData = await request.formData() const password = formData.get(\u0026#39;password\u0026#39;) if (password === PASSWORD) { const response = new Response(JSON.stringify({ success: true }), { headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; } }) response.headers.set(\u0026#39;Set-Cookie\u0026#39;, `auth=${PASSWORD}; HttpOnly; Secure; SameSite=Strict; Path=/; Max-Age=86400`) return response } else { return new Response(JSON.stringify({ success: false }), { headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; } }) } } else if (url.pathname === \u0026#39;/run\u0026#39; \u0026amp;\u0026amp; request.method === \u0026#39;POST\u0026#39;) { if (!isAuthenticated(request)) { return new Response(\u0026#39;Unauthorized\u0026#39;, { status: 401 }) } await handleScheduled(new Date().toISOString()) const results = await CRON_RESULTS.get(\u0026#39;lastResults\u0026#39;, \u0026#39;json\u0026#39;) return new Response(JSON.stringify(results), { headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; } }) } else if (url.pathname === \u0026#39;/results\u0026#39; \u0026amp;\u0026amp; request.method === \u0026#39;GET\u0026#39;) { if (!isAuthenticated(request)) { return new Response(JSON.stringify({ authenticated: false }), { headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; } }) } const results = await CRON_RESULTS.get(\u0026#39;lastResults\u0026#39;, \u0026#39;json\u0026#39;) return new Response(JSON.stringify({ authenticated: true, results: results || [] }), { headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; } }) } else if (url.pathname === \u0026#39;/check-auth\u0026#39; \u0026amp;\u0026amp; request.method === \u0026#39;GET\u0026#39;) { return new Response(JSON.stringify({ authenticated: isAuthenticated(request) }), { headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; } }) } else { // 显示登录页面或结果页面的 HTML return new Response(getHtmlContent(), { headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/html\u0026#39; }, }) } } function isAuthenticated(request) { const cookies = request.headers.get(\u0026#39;Cookie\u0026#39;) if (cookies) { const authCookie = cookies.split(\u0026#39;;\u0026#39;).find(c =\u0026gt; c.trim().startsWith(\u0026#39;auth=\u0026#39;)) if (authCookie) { const authValue = authCookie.split(\u0026#39;=\u0026#39;)[1] return authValue === PASSWORD } } return false } function getHtmlContent() { return ` \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Worker Control Panel\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { font-family: Arial, sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; background-color: #f0f0f0; } .container { text-align: center; padding: 20px; background-color: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); max-width: 800px; width: 100%; } input, button { margin: 10px 0; padding: 10px; width: 200px; border-radius: 4px; border: 1px solid #ddd; } button { background-color: #4CAF50; border: none; color: white; cursor: pointer; } #status { margin-top: 20px; font-weight: bold; } table { width: 100%; border-collapse: collapse; margin-top: 20px; } th, td { border: 1px solid #ddd; padding: 8px; text-align: left; } th { background-color: #f2f2f2; } #loginForm, #dashboard { display: none; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Worker Control Panel\u0026lt;/h1\u0026gt; \u0026lt;div id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; placeholder=\u0026#34;Enter password\u0026#34;\u0026gt; \u0026lt;button onclick=\u0026#34;login()\u0026#34;\u0026gt;Login\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;dashboard\u0026#34;\u0026gt; \u0026lt;button onclick=\u0026#34;runScript()\u0026#34;\u0026gt;Run Script\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;status\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;table id=\u0026#34;resultsTable\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Account\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Type\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Status\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Message\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Last Run\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt;\u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let password = \u0026#39;\u0026#39;; function showLoginForm() { document.getElementById(\u0026#39;loginForm\u0026#39;).style.display = \u0026#39;block\u0026#39;; document.getElementById(\u0026#39;dashboard\u0026#39;).style.display = \u0026#39;none\u0026#39;; } function showDashboard() { document.getElementById(\u0026#39;loginForm\u0026#39;).style.display = \u0026#39;none\u0026#39;; document.getElementById(\u0026#39;dashboard\u0026#39;).style.display = \u0026#39;block\u0026#39;; fetchResults(); } async function checkAuth() { const response = await fetch(\u0026#39;/check-auth\u0026#39;); const data = await response.json(); if (data.authenticated) { showDashboard(); } else { showLoginForm(); } } async function login() { password = document.getElementById(\u0026#39;password\u0026#39;).value; const formData = new FormData(); formData.append(\u0026#39;password\u0026#39;, password); const response = await fetch(\u0026#39;/login\u0026#39;, { method: \u0026#39;POST\u0026#39;, body: formData }); const result = await response.json(); if (result.success) { showDashboard(); } else { alert(\u0026#39;Incorrect password\u0026#39;); } } async function runScript() { const statusDiv = document.getElementById(\u0026#39;status\u0026#39;); statusDiv.textContent = \u0026#39;Executing script...\u0026#39;; try { const response = await fetch(\u0026#39;/run\u0026#39;, { method: \u0026#39;POST\u0026#39; }); if (response.ok) { const results = await response.json(); displayResults(results); statusDiv.textContent = \u0026#39;Script executed successfully!\u0026#39;; } else if (response.status === 401) { statusDiv.textContent = \u0026#39;Unauthorized. Please login again.\u0026#39;; showLoginForm(); } else { statusDiv.textContent = \u0026#39;Error executing script.\u0026#39;; } } catch (error) { statusDiv.textContent = \u0026#39;Error: \u0026#39; + error.message; } } async function fetchResults() { try { const response = await fetch(\u0026#39;/results\u0026#39;); if (response.ok) { const data = await response.json(); if (data.authenticated) { displayResults(data.results); } else { showLoginForm(); } } else { console.error(\u0026#39;Failed to fetch results\u0026#39;); showLoginForm(); } } catch (error) { console.error(\u0026#39;Error fetching results:\u0026#39;, error); showLoginForm(); } } function displayResults(results) { const tbody = document.querySelector(\u0026#39;#resultsTable tbody\u0026#39;); tbody.innerHTML = \u0026#39;\u0026#39;; results.forEach(result =\u0026gt; { result.cronResults.forEach((cronResult, index) =\u0026gt; { const row = tbody.insertRow(); if (index === 0) { row.insertCell(0).textContent = result.username; row.insertCell(1).textContent = result.type; } else { row.insertCell(0).textContent = \u0026#39;\u0026#39;; row.insertCell(1).textContent = \u0026#39;\u0026#39;; } row.insertCell(2).textContent = cronResult.success ? \u0026#39;Success\u0026#39; : \u0026#39;Failed\u0026#39;; row.insertCell(3).textContent = cronResult.message; row.insertCell(4).textContent = new Date(result.lastRun).toLocaleString(); }); }); } // 页面加载时检查认证状态 document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, checkAuth); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; `; } async function handleScheduled(scheduledTime) { const accountsData = JSON.parse(ACCOUNTS_JSON); const accounts = accountsData.accounts; let results = []; for (const account of accounts) { const result = await loginAccount(account); results.push(result); await delay(Math.floor(Math.random() * 8000) + 1000); } // 保存结果到 KV 存储 await CRON_RESULTS.put(\u0026#39;lastResults\u0026#39;, JSON.stringify(results)); } function generateRandomUserAgent() { const browsers = [\u0026#39;Chrome\u0026#39;, \u0026#39;Firefox\u0026#39;, \u0026#39;Safari\u0026#39;, \u0026#39;Edge\u0026#39;, \u0026#39;Opera\u0026#39;]; const browser = browsers[Math.floor(Math.random() * browsers.length)]; const version = Math.floor(Math.random() * 100) + 1; const os = [\u0026#39;Windows NT 10.0\u0026#39;, \u0026#39;Macintosh\u0026#39;, \u0026#39;X11\u0026#39;]; const selectedOS = os[Math.floor(Math.random() * os.length)]; const osVersion = selectedOS === \u0026#39;X11\u0026#39; ? \u0026#39;Linux x86_64\u0026#39; : selectedOS === \u0026#39;Macintosh\u0026#39; ? \u0026#39;Intel Mac OS X 10_15_7\u0026#39; : \u0026#39;Win64; x64\u0026#39;; return `Mozilla/5.0 (${selectedOS}; ${osVersion}) AppleWebKit/537.36 (KHTML, like Gecko) ${browser}/${version}.0.0.0 Safari/537.36`; } async function loginAccount(account) { const { username, password, panelnum, type, cronCommands } = account let baseUrl = type === \u0026#39;ct8\u0026#39; ? \u0026#39;https://panel.ct8.pl\u0026#39; : `https://panel${panelnum}.serv00.com` let loginUrl = `${baseUrl}/login/?next=/cron/` const userAgent = generateRandomUserAgent(); try { const response = await fetch(loginUrl, { method: \u0026#39;GET\u0026#39;, headers: { \u0026#39;User-Agent\u0026#39;: userAgent, }, }) const pageContent = await response.text() const csrfMatch = pageContent.match(/name=\u0026#34;csrfmiddlewaretoken\u0026#34; value=\u0026#34;([^\u0026#34;]*)\u0026#34;/) const csrfToken = csrfMatch ? csrfMatch[1] : null if (!csrfToken) { throw new Error(\u0026#39;CSRF token not found\u0026#39;) } const initialCookies = response.headers.get(\u0026#39;set-cookie\u0026#39;) || \u0026#39;\u0026#39; const formData = new URLSearchParams({ \u0026#39;username\u0026#39;: username, \u0026#39;password\u0026#39;: password, \u0026#39;csrfmiddlewaretoken\u0026#39;: csrfToken, \u0026#39;next\u0026#39;: \u0026#39;/cron/\u0026#39; }) const loginResponse = await fetch(loginUrl, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, \u0026#39;Referer\u0026#39;: loginUrl, \u0026#39;User-Agent\u0026#39;: userAgent, \u0026#39;Cookie\u0026#39;: initialCookies, }, body: formData.toString(), redirect: \u0026#39;manual\u0026#39; }) if (loginResponse.status === 302 \u0026amp;\u0026amp; loginResponse.headers.get(\u0026#39;location\u0026#39;) === \u0026#39;/cron/\u0026#39;) { const loginCookies = loginResponse.headers.get(\u0026#39;set-cookie\u0026#39;) || \u0026#39;\u0026#39; const allCookies = combineCookies(initialCookies, loginCookies) // 访问 cron 列表页面 const cronListUrl = `${baseUrl}/cron/` const cronListResponse = await fetch(cronListUrl, { headers: { \u0026#39;Cookie\u0026#39;: allCookies, \u0026#39;User-Agent\u0026#39;: userAgent, } }) const cronListContent = await cronListResponse.text() console.log(`Cron list URL: ${cronListUrl}`) console.log(`Cron list response status: ${cronListResponse.status}`) console.log(`Cron list content (first 1000 chars): ${cronListContent.substring(0, 1000)}`) let cronResults = []; for (const cronCommand of cronCommands) { if (!cronListContent.includes(cronCommand)) { // 访问添加 cron 任务页面 const addCronUrl = `${baseUrl}/cron/add` const addCronPageResponse = await fetch(addCronUrl, { headers: { \u0026#39;Cookie\u0026#39;: allCookies, \u0026#39;User-Agent\u0026#39;: userAgent, \u0026#39;Referer\u0026#39;: cronListUrl, } }) const addCronPageContent = await addCronPageResponse.text() console.log(`Add cron page URL: ${addCronUrl}`) console.log(`Add cron page response status: ${addCronPageResponse.status}`) console.log(`Add cron page content (first 1000 chars): ${addCronPageContent.substring(0, 1000)}`) const newCsrfMatch = addCronPageContent.match(/name=\u0026#34;csrfmiddlewaretoken\u0026#34; value=\u0026#34;([^\u0026#34;]*)\u0026#34;/) const newCsrfToken = newCsrfMatch ? newCsrfMatch[1] : null if (!newCsrfToken) { throw new Error(\u0026#39;New CSRF token not found for adding cron task\u0026#39;) } const formData = new URLSearchParams({ \u0026#39;csrfmiddlewaretoken\u0026#39;: newCsrfToken, \u0026#39;spec\u0026#39;: \u0026#39;manual\u0026#39;, \u0026#39;minute_time_interval\u0026#39;: \u0026#39;on\u0026#39;, \u0026#39;minute\u0026#39;: \u0026#39;15\u0026#39;, \u0026#39;hour_time_interval\u0026#39;: \u0026#39;each\u0026#39;, \u0026#39;hour\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;day_time_interval\u0026#39;: \u0026#39;each\u0026#39;, \u0026#39;day\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;month_time_interval\u0026#39;: \u0026#39;each\u0026#39;, \u0026#39;month\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;dow_time_interval\u0026#39;: \u0026#39;each\u0026#39;, \u0026#39;dow\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;command\u0026#39;: cronCommand, \u0026#39;comment\u0026#39;: \u0026#39;Auto added cron job\u0026#39; }) console.log(\u0026#39;Form data being sent:\u0026#39;, formData.toString()) const { success, response: addCronResponse, content: addCronResponseContent } = await addCronWithRetry(addCronUrl, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, \u0026#39;Cookie\u0026#39;: allCookies, \u0026#39;User-Agent\u0026#39;: userAgent, \u0026#39;Referer\u0026#39;: addCronUrl, \u0026#39;Origin\u0026#39;: baseUrl, \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\u0026#39;, \u0026#39;Accept-Language\u0026#39;: \u0026#39;en-US,en;q=0.5\u0026#39;, \u0026#39;Upgrade-Insecure-Requests\u0026#39;: \u0026#39;1\u0026#39; }, body: formData.toString(), }) console.log(\u0026#39;Full response content:\u0026#39;, addCronResponseContent) if (success) { if (addCronResponseContent.includes(\u0026#39;Cron job has been added\u0026#39;) || addCronResponseContent.includes(\u0026#39;Zadanie cron zostało dodane\u0026#39;)) { const message = `添加了新的 cron 任务：${cronCommand}`; console.log(message); await sendTelegramMessage(`账号 ${username} (${type}) ${message}`); cronResults.push({ success: true, message }); } else { // 如果响应中没有成功信息，再次检查cron列表 const checkCronListResponse = await fetch(cronListUrl, { headers: { \u0026#39;Cookie\u0026#39;: allCookies, \u0026#39;User-Agent\u0026#39;: userAgent, } }); const checkCronListContent = await checkCronListResponse.text(); if (checkCronListContent.includes(cronCommand)) { const message = `确认添加了新的 cron 任务：${cronCommand}`; console.log(message); await sendTelegramMessage(`账号 ${username} (${type}) ${message}`); cronResults.push({ success: true, message }); } else { const message = `尝试添加 cron 任务：${cronCommand}，但在列表中未找到。可能添加失败。`; console.error(message); cronResults.push({ success: false, message }); } } } else { const message = `添加 cron 任务失败：${cronCommand}`; console.error(message); cronResults.push({ success: false, message }); } } else { const message = `cron 任务已存在：${cronCommand}`; console.log(message); cronResults.push({ success: true, message }); } } return { username, type, cronResults, lastRun: new Date().toISOString() }; } else { const message = `登录失败，未知原因。请检查账号和密码是否正确。`; console.error(message); return { username, type, cronResults: [{ success: false, message }], lastRun: new Date().toISOString() }; } } catch (error) { const message = `登录或添加 cron 任务时出现错误: ${error.message}`; console.error(message); return { username, type, cronResults: [{ success: false, message }], lastRun: new Date().toISOString() }; } } async function addCronWithRetry(url, options, maxRetries = 3) { for (let i = 0; i \u0026lt; maxRetries; i++) { try { const response = await fetch(url, options); const responseContent = await response.text(); console.log(`Attempt ${i + 1} response status:`, response.status); console.log(`Attempt ${i + 1} response content (first 1000 chars):`, responseContent.substring(0, 1000)); if (response.status === 200 || response.status === 302 || responseContent.includes(\u0026#39;Cron job has been added\u0026#39;) || responseContent.includes(\u0026#39;Zadanie cron zostało dodane\u0026#39;)) { return { success: true, response, content: responseContent }; } } catch (error) { console.error(`Attempt ${i + 1} failed:`, error); } await delay(2000); // Wait 2 seconds before retrying } return { success: false }; } function combineCookies(cookies1, cookies2) { const cookieMap = new Map() const parseCookies = (cookieString) =\u0026gt; { cookieString.split(\u0026#39;,\u0026#39;).forEach(cookie =\u0026gt; { const [fullCookie] = cookie.trim().split(\u0026#39;;\u0026#39;) const [name, value] = fullCookie.split(\u0026#39;=\u0026#39;) if (name \u0026amp;\u0026amp; value) { cookieMap.set(name.trim(), value.trim()) } }) } parseCookies(cookies1) parseCookies(cookies2) return Array.from(cookieMap.entries()).map(([name, value]) =\u0026gt; `${name}=${value}`).join(\u0026#39;; \u0026#39;) } async function sendTelegramMessage(message) { const telegramConfig = JSON.parse(TELEGRAM_JSON) const { telegramBotToken, telegramBotUserId } = telegramConfig const url = `https://api.telegram.org/bot${telegramBotToken}/sendMessage` try { await fetch(url, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ chat_id: telegramBotUserId, text: message }) }) } catch (error) { console.error(\u0026#39;Error sending Telegram message:\u0026#39;, error) } } function delay(ms) { return new Promise(resolve =\u0026gt; setTimeout(resolve, ms)) } ACCOUNTS_JSON 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { \u0026#34;accounts\u0026#34;: [ { \u0026#34;username\u0026#34;: \u0026#34;user1\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;password1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;ct8\u0026#34;, \u0026#34;cronCommands\u0026#34;: [ \u0026#34;/usr/home/serv00name/domains\u0026#34;, \u0026#34;你的脚本\u0026#34; ] }, { \u0026#34;username\u0026#34;: \u0026#34;user2\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;password2\u0026#34;, \u0026#34;panelnum\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;serv00\u0026#34;, \u0026#34;cronCommands\u0026#34;: [ \u0026#34;/usr/home/serv00name\u0026#34; ] }, { \u0026#34;username\u0026#34;: \u0026#34;user3\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;password3\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;ct8\u0026#34;, \u0026#34;cronCommands\u0026#34;: [ \u0026#34;/usr/home/serv00name\u0026#34;, \u0026#34;你的脚本\u0026#34;, \u0026#34;python /usr/home/serv00name/domains/backup.py\u0026#34; ] } ] } TELEGRAM_JSON 1 2 3 4 { \u0026#34;telegramBotToken\u0026#34;: \u0026#34;YOUR_BOT_TOKEN\u0026#34;, \u0026#34;telegramBotUserId\u0026#34;: \u0026#34;YOUR_USER_ID\u0026#34; } PASSWORD 1 你访问worker面板的密码 添加Cron 创建一个名为CRON_RESULTS的KV变量 回到刚才创建的worker界面绑定KV 访问你的worker网站并输入密码,点击运行脚本即可。 参考： https://linux.do/t/topic/181957 ","date":"2024-12-12T17:52:58+08:00","image":"https://roim-picx-9nr.pages.dev/rest/opJqrLK.png","permalink":"https://faust6312.github.io/p/cloudflare%E5%AE%9E%E7%8E%B0serv00%E8%B4%A6%E5%8F%B7%E4%BF%9D%E6%B4%BB%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%B9%B6%E6%8E%A5%E5%85%A5telegrame%E9%80%9A%E7%9F%A5/","title":"CloudFlare实现Serv00账号保活\u0026进程保活并接入telegrame通知"},{"content":"1.起因和前提准备 最近serv00的S14开了，撸了两个小鸡来玩，本来就苦代理费用久矣，故做此计\u0026mdash;-搭建代理节点自己用。一是费用问题。二是用别人的有安全隐患，总怕被“偷窥”，被DNS挟持之类的。于是便有了下文。\n前提准备： 1.注册登录serv00账号 2.开放serv00权限和端口 random一个tcp端口 2.通过脚本安装singbox并部署vmess节点 因为我不想要那么多协议的节点，故没有选择四合一三合一之类的脚本，选了一个修改版的只有vmess协议的脚本github地址为：https://github.com/amclubs/am-serv00-vmess\n脚本安装命令： 1 bash \u0026lt;(curl -Ls https://raw.githubusercontent.com/amclubs/am-serv00-vmess/main/install_serv00_vmess.sh) 安装 输入1安装sing-box\n确认安装并输入刚才Random出来的tcp端口\n确认使用argo隧道\n这里可以使用随机的argo隧道，但是还是直接用固定的argo隧道比较稳定。故按照脚本步骤直接跳转到如何创建argo隧道。\n固定argo隧道的创建 首先你要有一个托管到cf的域名，然后打开cf点击这里：\n(开启此功能需要绑定支付方式，我用的paypal可以绑定成功，白嫖免费套餐就行)\n然后点击tunnels\n创建一个隧道，名字随便\n继续\n输入隧道名字，点击部署\n把这个token复制出来备用\n点下一步按照下图填写对应内容\n点击这里查看隧道\n复制域名\n然后填入隧道名到面板，并输入刚才保存的token,就可以看到生成的节点了，导入v2ray就可以使用了\n设置端口回源 为了使用cf的优选ip提升节点速度我们需要设置端口回源\n点击你刚才使用的域名，选择DNS,点击编辑 将CNAME改为A记录，后面填写小鸡的ip,并启动小黄云 然后点击规则，点击origen rules创建一条规则 按照下图填写保存部署即可 然后在v2ray里面填写伪装域名 至此可以随便填写优选ip之类的，教程结束。 ","date":"2024-12-08T23:12:16+08:00","image":"https://roim-picx-9nr.pages.dev/rest/gJjL7LK.png","permalink":"https://faust6312.github.io/p/%E5%85%B3%E4%BA%8Eserv00-vmess-argo%E9%9A%A7%E9%81%93%E5%AE%9E%E7%8E%B0%E8%8A%82%E7%82%B9%E6%90%AD%E5%BB%BA%E5%92%8C%E5%8A%A0%E9%80%9F/","title":"关于Serv00+Vmess+Argo隧道实现节点搭建和加速"},{"content":"一、Docker安装Aria2 1、使用拉取aria2镜像 1 docker pull p3terx/aria2-pro 2、启动容器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 docker run -d \\ --name aria2 \\ --restart unless-stopped \\ --log-opt max-size=1m \\ -e PUID=$UID \\ -e PGID=$GID \\ -e UMASK_SET=022 \\ -e RPC_SECRET=prc_password \\ #密钥 -e RPC_PORT=6800 \\ #设置PRC通讯端口（与宿主主机的端口映射一致） -e LISTEN_PORT=6888 \\ # 监听端口 -p 16800:6800 \\ #为RPC 通讯端口映射 -p 16888:6888 \\ #为BT 监听端口（TCP）映射，即 Aria2 配置中listen-port选项定义的端口 -p 16888:6888/udp \\ #为DHT 监听端口（UDP）映射，即 Aria2 配置中dht-listen-port选项定义的端口 -v /root/aria2/config:/config \\ -v /root/aria2/downloads:/downloads \\ p3terx/aria2-pro 二、Docker安装AriaNg 1、拉取AriaNg镜像\n1 docker pull p3terx/ariang 2、启动容器\n1 2 3 4 5 6 docker run -d \\ --name ariang \\ --log-opt max-size=1m \\ --restart unless-stopped \\ -p 16880:6880 \\ p3terx/ariang 3、访问 http://你的服务器ip:16880 访问AriaNg的web管理界面 4、点击“AriaNg 设置”菜单，再点击“全局”右边的标签配置RPC 5、配置完刷新一下页面，如果状态显示“已连接”就ok了\n","date":"2024-12-04T14:30:51+08:00","image":"https://roim-picx-9nr.pages.dev/rest/aZfaZkK.png","permalink":"https://faust6312.github.io/p/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAaria2-ariang%E5%AE%9E%E7%8E%B0%E7%A6%BB%E7%BA%BF%E4%B8%8B%E8%BD%BD/","title":"使用Docker搭建Aria2+AriaNG实现离线下载"},{"content":"1.在 GitHub 上创建和配置仓库 访问 roim-picx 并将其 fork 到你的账号下。 2.使用 Cloudflare Pages 搭建图床服务 登录 Cloudflare，并根据下图指示连接到 GitHub。 选择pages 选择你刚才 fork 的仓库并开始设置。 按照默认设置保存并部署(这里选VUE)。 部署成功后，会显示一个页面，其中包含图床的网址。 3.管理图床 新建KV空间 新建R2存储 进入设置绑定下图三个变量 进入KV设置登录密码 最后，重新部署服务。 现在，通过图床域名就可以访问了，输入TOKEN就可以进入上传和管理界面。 ","date":"2024-11-30T16:20:36+08:00","image":"https://roim-picx-9nr.pages.dev/rest/W7U1qkK.png","permalink":"https://faust6312.github.io/p/cloudflare-roim-picx%E6%89%93%E9%80%A0%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8Atelegraph-image%E5%AF%84%E4%BA%86%E6%8D%A2%E6%88%90%E8%BF%99%E4%B8%AA/","title":"CloudFlare+roim-picx打造个人图床(Telegraph-Image寄了换成这个)"},{"content":"1.环境准备 1.1下载配置git环境 不赘述，网上有很多教程\n1.2下载配置hugo环境 前往【Hugo Github Tags】，选择对应版本下载，下载后解压即可\nWindows下载版本：hugo_extended_xxxxx_windows_amd64.zip\n这里可以在网上搜索配置一下hugo的环境变量，不配置也行，直接复制一份.exe文件到你要操作的文件夹也能在cmd用hugo命令\n2.搭建博客 2.1 创建博客 （1）在hugo.exe所在文件夹的地址栏敲打cmd，然后Enter唤起命令行\n（2）输入命令`hugo new site myblgo(你存放博客文件的文件夹名)创建hugo文件\n（3）输入命名cd myblog切换目录，并把hugo.exe复制到刚生成的文件夹中(配置了环境变量可以不用复制)\n（4）输入命令hugo server -D启动服务，访问http://localhost:1313，Ctrl+C停止服务 （hugo默认是没有主题的，需要进行主题配置） 现在浏览器看到的是 2.2 配置主题 （1)前往，查找自己喜欢的主题，进行下载\n（2）这边以【Stack主题】为例，将下载好的主题解压，放到/themes文件夹中 （3）将exampleSite样例数据中的 Content 和 hugo.yaml 复制到主文件夹中，并删掉hugo.toml和content/post/rich-content\n（4）修改 hugo.yaml 中的 theme，将他修改为跟主题文件夹同名(让主题生效)\n3.部署博客 3.1 常规部署 （1）前往【Github官网】，创建仓库** {github用户名}.github.io** （2）前往Setting -\u0026gt; Pages -\u0026gt; Branch选择main分支(我是老版本的master，自行分辨)，然后保存，会自动开启 https://{github用户名}.github.io 的地址，这地址也是以后访问博客的地址 （3）回到hugo文件中，执行命令hugo -D，会生成 public 静态资源文件夹 （4）在 public 执行以下命令上传到github仓库上 1 2 3 4 5 git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main （5）上传成功后访问 **https://{github用户名}.github.io **，成功搭建属于自己的Hugo博客 3.2 Github Action自动部署 （1）Github创建一个新的仓库，用于存放Hugo的主文件 （2）前往Setttings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens，创建一个token(classic) （3）token选择永不过期，并勾选 repo 和 workflow 选项 （4）为保证安全，将生成的token，保存的仓库的变量中，前往Settings -\u0026gt; Secrets and variables -\u0026gt; Actions中设置 （5）在hugo主文件创建一个.github/workflows/xxxx.yaml文件，将以下内容复制进去，想具体了解更多，可查看GitHubAction文档 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 代码提交到main分支时触发github action on: push: branches: - main #我的是master分支，请自行更改 jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main #如果你是master分支这里也记得改 PUBLISH_DIR: ./public commit_message: auto deploy 6）在hugo主文件创建.gitignore文件，来避免提交不必要的文件 1 2 3 4 5 6 public resources .hugo_build.lock # hugo命令 hugo.exe （7）将hugo的主文件上传到仓库，上传成功后会触发Github Action，来自动部署你的静态页面 1 2 3 4 5 git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main ———————————————————————————————————————————\n4.配置 Waline 评论系统 4.1在 LeanCloud 上部署数据库 进入 LeanCloud 国际版，进行 注册 （推荐国际版是因为国内版的需要域名备案，详情可以去官方文档查看） 进入控制台，点击左上角「创建应用」并起一个你喜欢的名字 (请选择免费的开发版) 直接进入左下角「设置」-\u0026gt;「应用凭证」，将 AppID、AppKey和 MasterKey复制- 保存下来 4.2在 Vercel 上部署服务端 1.进入 Vercel 使用 Github 登录后进行部署\n2.Git Scope 选择自己的 Github 账号；Repository Name 填自己喜欢的名字；Create private Git Repository 是选择是否设置为个人仓库，建议选择默认件中配置客户端 3.等待Vercel自动创建和初始化 Waline 仓库，初始化完毕后点击 Go to Dashboard 跳转到应用控制台。\n4.进入项目的「Settings -\u0026gt; Environment Variables」，创建三个值 LEAN_ID, LEAN_KEY 和 LEAN_MASTER_KEY，分别在对应的 Value填上在 LeanCloud 获得的 AppID、AppKey和 MasterKey。 5.点击顶部「Deployments」选项卡，再点击最新一次的部署右边的「···」，选择「Redeploy」。\n6.此时会跳转到「Overview」界面开始部署，等待片刻后 STATUS 会变成 Ready。\n7.再点击「Visit」，即可跳转到部署好的网站地址，此地址即为你的服务端地址。\n8.最后打开站点根目录下的 config.yaml，在 params 下添加以下几行：（如果你当初拷贝了 Stack 提供的 config.yaml 文件，那么这段在第 60 行左右，只需填入 serverURL 即可）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 waline: serverURL: https://\u0026lt;PUT_YOUR_OWN_HERE\u0026gt;.vercel.app/ lang: zh-CN visitor: true avatar: emoji: - https://cdn.jsdelivr.net/gh/walinejs/emojis/qq requiredMeta: - name - email - url placeholder: locale: admin: Admin 注意在这段代码上面把comment : faise \u0026ndash;\u0026gt;改为true\n评论管理 评论管理 (管理端) 部署完成后，请访问 /ui/register 进行注册。首个注册的人会被设定成管理员。 管理员登陆后，即可看到评论管理界面。在这里可以修改、标记或删除评论。 用户也通过评论框注册账号，登陆后会跳转到自己的档案页。 ———————————————————————————————————————————\n5.自定义域名 1.域名 首先你要有一个域名，并且这个域名有DNS解析服务，我的域名是托管到CloundFlare上的，域名解析也是用的它。 2.绑定 1.在setting种找到pages 2.在这里输入你的域名 3.在hugo的主仓库加入一个CNAME文件（里面写你的域名），这样构建的时候就会生成一个CNAME文件不用担心push的时候被顶掉 到此部署已经基本结束，博客详细美化请自行搜索，不同主题之间亦有差异。\n————————————————————————————————————————————————————————————\n写在后面：\n​\t好多人搭建完博客的第一件事就是写一一篇搭建博客的论文，薪火相传了属于是。好在互联网很大什么教程都能找到，搭建起来其实也不困难。\n搭建本博客用到的东西总结如下👇🏻👇🏻👇🏻。\n网页:hugo的stack主题+github\nDNS解析:CloudFlare\n评论功能:用的vercel部署的weline\n评论存储:LearnCloud\n自动化部署:github action\n域名:700050.xyz，是在spaceship买的便宜的6位数xyz域名,10年才40块，也可以搞免费的二级域名。本来是在阿里云买的域名，\n但是spaceship更便宜，阿里云的域名就被我66卖了，还赚了点，四舍五入等于20块买10年了属于是。\n参考：\n[1]https://letere-gzj.github.io/hugo-stack/p/hugo/custom-blog/\n[2]https://blog.reincarnatey.net/2023/build-hugo-blog-with-stack-mod/\n[3]https://imayx.top/waline/#%e8%af%84%e8%ae%ba%e7%ae%a1%e7%90%86\n[4]https://www.hetong-re4per.com/posts/use-waline-comment-on-hugo/\n[5]https://juejin.cn/post/7093762255166111780#heading-3\n","date":"2024-11-28T17:00:45+08:00","image":"https://faust6312.github.io/p/%E4%BD%BF%E7%94%A8hugo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/QQ20241128-150725_hu8770114893643075218.png","permalink":"https://faust6312.github.io/p/%E4%BD%BF%E7%94%A8hugo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","title":" 使用hugo+github搭建博客"},{"content":"Silence wench，🗡️ I do not wish to be horny anymore，I just want to be happy 噢喔喔喔喔，啊咦嘢，喔喔～[doge]💧👒🗡️🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸←[doge]👒🗡️🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸🌸\n","date":"2024-11-27T10:59:45+08:00","image":"https://faust6312.github.io/p/for-cheems/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://faust6312.github.io/p/for-cheems/","title":" FOR CHEEMS"},{"content":"1.安装lib32stdc++6来支持32bit程序 指令: sudo apt-get install lib32stdc++6 lib32stdc++6是C++标准库的一个32位版本，主要用于在64位的Ubuntu系统上运行需要32位 库支持的应用程序或软件。为什么要安装呢？因为linux系统的steam只有32位。\n2.下载解压运行并登录steam （如果一些命令没权限就在前面加一个sudo）\ncd /usr/local/ （切换到这个目录下）\nmkdir steamcmd （创建一个steamcmd 文件夹）\ncd steamcmd/ （切换到刚创建的steamcmd 文件夹）\nwget https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz （下载steamcmd）\ntar -zxvf steamcmd_linux.tar.gz （解压）\n./steamcmd.sh（运行steamcmd）\n安装完成后会有个 steam\u0026gt; 的符号,意味着已经进入了控制台版本的steam 下面是登录操作： (假如我的账号是114514，密码是1919810） 则输入：\nlogin 114514 1919810 如果有steam令牌还需要输入steam令牌\n3.下载僵尸毁灭工程 登录成功后输入：\napp_update 380870 validate (有时候由于网络问题有可能一次下不完整，可以再输一遍命令）\n下载完成后输入：\nexit 退出steamCMD\n输入：tmux 进入tmux\n(用tmux保一下进程)\n然后输入：\ncd ~ 再然后再输入 ：\ncd Steam/steamapps/common/\ncd Project\\ Zomboid\\ Dedicated\\ Server/\n最后再输入 :\n./start-server.sh 启动服务器。\n后面会要你设置一个僵毁服务器密码，需要输入两遍，请自行设置。\n启动后如果无法连接到服务器那多半就是没开放端口，请在你购买的云服务器开放一下，这里以腾讯云为例\n4.如何进行更新操作： (1).启动steamcmd\n/usr/local/steamcmd/steamcmd.sh\n(2).登录\nlogin 用户名 密码 令牌\n(3).更新\napp_update 380870 validate\n5.如何添加模组： 先配置好一个服务器配置文件，例如：\n默认保存在这个路径下：C:\\Users\\XXXX\\Zomboid\\Server，配置的时候也能看到路径 然后拿这个配置文件替换掉服务器的配置文件就行了,再次启动服务器会自己加载mod。\n","date":"2024-11-26T21:00:44+08:00","image":"https://faust6312.github.io/p/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8ubuntu%E6%90%AD%E5%BB%BA%E5%83%B5%E5%B0%B8%E6%AF%81%E7%81%AD%E5%B7%A5%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/20241021215100_1_hu1139309777479379506.png","permalink":"https://faust6312.github.io/p/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8ubuntu%E6%90%AD%E5%BB%BA%E5%83%B5%E5%B0%B8%E6%AF%81%E7%81%AD%E5%B7%A5%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"关于使用Ubuntu搭建僵尸毁灭工程服务器"},{"content":"它要宽宽敞敞\n让人可以随处坐下\n它要有速度，有风景掠过窗前\n让有的人发呆，有的人晕眩\n它要颠簸着行驶，让人们\n不得不紧紧抓住什么\n它要有进口，让一些人拥挤着进来\n它还要有出口，让另一些人\n也可以抱怨着离开\n","date":"2020-09-09T00:00:00Z","image":"https://faust6312.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"https://faust6312.github.io/p/test-chinese/","title":"关于诗"},{"content":"有什么值得大海去蓝\n有什么值得大海苍老\n太多的过眼烟云\n包括你\n包括我\n有什么值得大海心痛\n太多的知识\n使大海充满了苦涩\n也使它变得\n像一个巨大的筛子\n有什么值得它去蓝\n有什么值得它汹涌\n海水松开手指\n只有遗忘，只有经过\n有什么值得大海挽留\n","date":"2019-03-11T00:00:00Z","image":"https://faust6312.github.io/p/%E6%9C%89%E4%BB%80%E4%B9%88%E5%80%BC%E5%BE%97%E5%A4%A7%E6%B5%B7%E5%8E%BB%E8%93%9D/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://faust6312.github.io/p/%E6%9C%89%E4%BB%80%E4%B9%88%E5%80%BC%E5%BE%97%E5%A4%A7%E6%B5%B7%E5%8E%BB%E8%93%9D/","title":"有什么值得大海去蓝"},{"content":"撕开一场雨直到露出它的茎干\n裂纹扩展至众多的时刻和地点\n如果我喜欢的东西还没出现\n那只不过说明\n其实我自己也只能在一些过时的歌曲里容身\n我的疑问比畏惧更强烈\n我的习惯是抽出事物的全部神经\n握在手里，让它们冷却成语言\n温柔和花色雨水一样退下\n我要撕开它们直到露出最里面的夜\n","date":"2019-03-09T00:00:00Z","image":"https://faust6312.github.io/p/%E6%92%95%E5%BC%80%E4%B8%80%E5%9C%BA%E9%9B%A8%E7%9B%B4%E5%88%B0%E9%9C%B2%E5%87%BA%E5%AE%83%E7%9A%84%E8%8C%8E%E5%B9%B2/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"https://faust6312.github.io/p/%E6%92%95%E5%BC%80%E4%B8%80%E5%9C%BA%E9%9B%A8%E7%9B%B4%E5%88%B0%E9%9C%B2%E5%87%BA%E5%AE%83%E7%9A%84%E8%8C%8E%E5%B9%B2/","title":"撕开一场雨直到露出它的茎干"},{"content":"它们在比牙缝更狭小的角落\n扎下根来\n在靠近心脏的地方\n在我的身后\n我即使突然转身\n也无法把它们看见\n我从哪里\n继承了它们\n它们又来自\n我的哪一些过失\n在夜深人静时\n它们开满四周\n丑陋的叶\n已把我的许多部分覆盖\n并通过秘密的路径\n蔓延\n在所有的生活和梦境\n也许该用刀\n对付这些茎叶\n但我又怎能\n挖到它的根\n","date":"2019-03-05T00:00:00Z","permalink":"https://faust6312.github.io/p/%E5%8F%A6%E4%B8%80%E7%A7%8D%E8%95%A8%E7%B1%BB/","title":"另一种蕨类"},{"content":"第一个人抬头看树\n有鸟，或者没有\n其实他只是看自己的心情\n第二个人把家安在妻子脸上\n第三个人不管干什么\n关节里总响着硬币的声音\n第四个人一直准备哭泣\n准备被感动，被安慰\n他的手绢\n就放在裤袋里\n第五个人模仿某人的语气和手势\n活下去的难题是\n学不会他吐痰的动作\n第六个人刚结束初恋\n他只剩下一只手一条腿和半边脑袋\n第七个人成了上层人物\n而且\n从此以后他的鼻音很重\n第八个人正和第九个人打架\n第十个人躲在一张面具后面\n直到他死\n我们也没有见过他的脸\n","date":"2019-03-05T00:00:00Z","image":"https://faust6312.github.io/p/%E4%BB%96%E4%BB%AC/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://faust6312.github.io/p/%E4%BB%96%E4%BB%AC/","title":"他们"}]